<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>归档 | Lost JavaScript</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta content="website" property="og:type">
<meta property="og:title">
<meta content="http://lostjs.com/archives/page/4/" property="og:url">
<meta property="og:image">
<meta content="Lost JavaScript" property="og:site_name">
<meta property="og:description">
<meta content="summary" name="twitter:card">
  
    <link rel="alternative" href="/atom.xml" title="Lost JavaScript" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="http://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-450827-9']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Lost JavaScript</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">天赋即兴趣 兴趣即天赋</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://lostjs.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-grunt-the-best" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2012/12/08/grunt-the-best/" class="article-date">
  <time datetime="2012-12-08T03:21:00.000Z" itemprop="datePublished">2012年12月08日</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/12/08/grunt-the-best/">Grunt -- 最好的前端构建框架</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>每个前端开发工程师都会遇到前端文件打包、压缩的问题。</p>
<h2 id="Shell_-&gt;_Ant_-&gt;_Jake">Shell -&gt; Ant -&gt; Jake</h2>
<p>最开始，我是用 shell 脚本调用 yuicompressor、cssmin 来压缩文件，非常简单，就像这样：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="preprocessor">#!/usr/bin/env bash</span>

cat src/a<span class="preprocessor">.js</span> src/b<span class="preprocessor">.js</span> src/c<span class="preprocessor">.js</span> &gt; dst/main<span class="preprocessor">.js</span>
yuicompressor main<span class="preprocessor">.js</span>

cat src/a<span class="preprocessor">.css</span> src/b<span class="preprocessor">.css</span> src/c<span class="preprocessor">.css</span> &gt; dst/main<span class="preprocessor">.css</span>
cssmin main<span class="preprocessor">.css</span>
</pre></td></tr></table></figure>

<p>后来随着项目规模的逐渐增大，shell 脚本逐渐暴露出了很多问题，比如：</p>
<ul>
<li>不能自动下载依赖的外部命令，比如 yuicompressor/cssmin</li>
<li>缺乏变量替换功能</li>
<li>难以跨平台</li>
<li>代码难以维护</li>
</ul>
<p>因此 shell 脚本在到了近百行以后就被放弃了，取而代之的是 Ant。Ant 内置了一些常见任务，比如文件复制、合并、变量替换等，并且可以方便的通过编写自定义任务来扩展。得益于 Java 灵活的扩展性，Ant 任务可以非常方便的在各个项目之间分享，很好的解决了 shell 脚本代码难以维护和迁移的缺点。Ant 还可以结合 ivy 自动解决依赖，实现了完全的跨平台支持。</p>
<ul>
<li>推荐文章：<a href="http://www.36ria.com/4411" target="_blank">ant入门指南—web前端开发七武器（1）</a></li>
</ul>
<p>但是，Ant 有个缺点：它是 Java 写的。Ant 如果要执行 js 代码，就必须通过 rhino，速度比 nodejs 慢了不少，作为一个 JavaScript 工程师，我非常希望可以直接用 js 来写构建脚本。</p>
<p>最终让我放弃 Ant 的是一个新的项目。这个项目的特殊之处在于它用了 maven 作为 Java 的构建工具。之前用的各种 Ant 任务也就没有了用武之地。尽管我可以将 Ant 的任务迁移到 mavn 下面，但是我更希望能找到一个和后台语言完全无关的构建系统。</p>
<p>因此在今年年初，我找到了一个 nodejs 环境下的构建框架 <a href="https://github.com/mde/jake" target="_blank">Jake</a>。Jake 的各种编译任务由 <code>Jakefile</code> 中定义（这一点很像 Make），<code>Jakefile</code> 实际上就是一个 js 文件，通过 nodejs 来执行压缩合并等常见任务。</p>
<p>得益于 nodejs，Jake 执行 js 代码压缩的速度非常快，而且开发调试也更加方便。但是有个和 shell 脚本类似的问题：不同项目间的 Jake 任务难以重用，项目大了以后 <code>Jakefile</code> 依然很难维护，面对一个上千行的 <code>Jakefile</code>，和面对一个几百行的 shell 脚本的感觉差不了太多。</p>
<p>以上就是我从 Shell 到 Ant 再到 Jake 的折腾经历。经历这么一圈之后，我发现一个好用的构建框架应该具有以下三个特点：</p>
<ul>
<li>跨平台（Ant, Jake）</li>
<li>易维护、易迁移（Ant）</li>
<li>开发简单（Shell，Jake）</li>
</ul>
<p><a href="http://gruntjs.com" target="_blank">grunt</a> 就是同时具有以上三个特点的前端构建框架。</p>
<h2 id="grunt">grunt</h2>
<p><a href="http://gruntjs.com" target="_blank">grunt</a> 是一个开源的基于任务 (Task) 的前端构建框架。它除了有 Jake 的优点（跨平台、开发简单）以外，还有一套设计良好的 task 框架用来组织各种构建任务。grunt 内置了几个非常常见的构建任务：</p>
<ul>
<li>concat - 组合各种文件</li>
<li>lint - 用 JSHint 检查代码</li>
<li>min - 用 UglifyJS 压缩代码</li>
<li>qunit - 跑 QUnit 单元测试</li>
<li>watch - 当源代码文件发生变化时自动执行任务</li>
</ul>
<p>除此之外还可以通过 npm 来方便的获取几百个现成的 task，比如用 closure 而不是 UglifyJS 来压缩 js，或者用 less 来生成 css，又或者用 jslint 而不是 jshint 来检查语法等，这些任务都可以在 npm 上找到。如果这些任务无法满足你的需求，grunt 还允许你方便的添加自定任务，就像写 nodejs 代码一样简单。自定任务还可以发布到 npm 上，通过 npm 在多个项目中共享这些任务。[fenbi-grunt-tasks] 就是粉笔网自定的 js 模块合并、handlebars 模板预编译任务 ([grunt-tbf2e] 貌似是淘宝的自定任务)。</p>
<p>任务之间的组合也是 grunt 非常好用的一个特性，例如通过 watch 任务和 rsync 任务的结合，可以方便的实现当源码发生改变时，自动同步代码到服务器上。</p>
<p>每次 grunt 执行时，grunt 都会去读取当前目录下的 <code>grunt.js</code> (就像 make 命令去寻找 Makefile 那样)，然后去读取其中的任务配置，例如源码目录等。grunt 最大的特点在于，配置文件中不包含任何的任务逻辑代码(OO 的开闭原则)。这一特性使得任务可以专心于“要做什么”而不是“要对什么做事情”，不再被特定的项目所绑架。</p>
<ul>
<li>推荐阅读：<a href="http://www.oschina.net/question/89964_47198" target="_blank">grunt简要介绍—基于任务的JavaScript项目命令行构建工具</a></li>
</ul>
<p>grunt 给我最大的感受是：原来天下有这么多码农都在为前端构建而奋斗！grunt 使得各个项目的构建脚本不再彼此孤立，使得打造整个公司的前端构建工具变的更加简单。</p>

        <p>- FIN -</p>
      
    </div>
    
    <footer class="article-footer">
      <a data-url="http://lostjs.com/2012/12/08/grunt-the-best/" data-id="0xc803ghwjy4gc56" class="article-share-link">分享</a>
      
      
        <a href="http://lostjs.com/2012/12/08/grunt-the-best/#comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/grunt/">grunt</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-zsh" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2012/09/27/zsh/" class="article-date">
  <time datetime="2012-09-27T04:39:00.000Z" itemprop="datePublished">2012年09月27日</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/09/27/zsh/">使用 zsh 的九个理由</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>像大部分 *nix 用户，我之前用 bash 很多年，期间也有过小的不爽，但一直都忍过来，或者是说没想过这些不爽的地方能解决，比如 <code>cd</code> 到一个深目录时得哐哐猛敲 <code>&lt;TAB&gt;</code>。这么多年里我也尝试过其他 shell。比如 ksh/tcsh 以及今天要说的 zsh，但最终都没坚持下去，因为心中始终还是认为 bash 是最正统的 shell，不愿意去主动深入学习其他 shell。直到前几天逛 github，发现 <a href="https://github.com/popular/forked" target="_blank">排名第 6 的开源项目 oh-my-zsh</a>，下来试用了一把，顿时觉得 bash 各种操作不爽到无法忍受。</p>
<h2 id="放弃_bash_的各种内牛满面的理由">放弃 bash 的各种内牛满面的理由</h2>
<p>这里有个 youtube 上的视频，短短 4 分钟就已经抛出了几十个让 bash 用户切换到 zsh 中的理由。<a href="http://youtu.be/HGBgMX5HW_g" target="_blank">视频链接</a></p>
<h3 id="理由_0：zsh_兼容_bash">理由 0：zsh 兼容 bash</h3>
<p>兼容 bash 意味着我不需要太多学习成本就可以切换过来，意味着我以前在 bash 下积累的 shell 语法、基本操作都不会荒废。在我心里 bash 还是最通用和标准的 shell 环境，因此兼容 bash 让我切换到 zsh 时没有太多后顾之忧。</p>
<h3 id="理由_1：zsh_的补全模式更方便">理由 1：zsh 的补全模式更方便</h3>
<p>zsh 中按两下 tab 键可以触发 zsh 的补全，所有待补全项都可以通过键盘方向键或者 <code>&lt;Ctrl-n/p/f/b&gt;</code> 来选择。</p>
<img src="http://www.geekpics.net/images/2012/09/27/j4Ho9.png" title="zsh 的交互式补全模式">


<h3 id="理由_2：zsh_支持命令选项补全">理由 2：zsh 支持命令选项补全</h3>
<p>zsh 除了支持目录的补全，还支持命令选项的补全，例如 <code>ls -&lt;TAB&gt;&lt;TAB&gt;</code> 会直接列出所有 <code>ls</code> 的参数，再也不会出现一个命令打到一半，忘记参数导致重开一个 terminal <code>man</code> 一把。</p>
<img src="http://www.geekpics.net/images/2012/09/27/ZB7EC.png" title="zsh 补全 ls 命令的选项">


<h3 id="理由_3：zsh_支持命令参数补全">理由 3：zsh 支持命令参数补全</h3>
<p>以前想 <code>kill</code> 掉一个进程，我的做法是 <code>ps aux | grep &quot;进程名&quot;</code> 然后记下 id，再 <code>kill id</code>。在 <code>zsh</code> 下，只需要 <code>kill 进程名&lt;TAB&gt;</code>，<code>zsh</code> 就会自动补全进程的 pid。</p>
<img src="http://www.geekpics.net/images/2012/09/27/Xefxc.png" title="zsh 补全 kill 命令的参数">


<p>其余我常用的补全还有：</p>
<ul>
<li><code>ssh &lt;TAB&gt;&lt;TAB&gt;</code> 时 zsh 会自动列出你访问过的主机和用户名来补全 <code>ssh</code> 的参数。</li>
<li><code>brew install &lt;TAB&gt;&lt;TAB&gt;</code> 来补全软件包名，除了 homebrew 以外，同样支持 port/apt-get 等其他包管理器。</li>
</ul>
<h3 id="理由_4：zsh_支持更加聪明的目录补全">理由 4：zsh 支持更加聪明的目录补全</h3>
<p>以前比如想进入一个比较深的目录，比如 <code>/Users/pw/workspace/project/src/main/webapps/static/js</code>，就得在 bash 下面打半天，不停的 tab 去补全一个正确的路径出来。在 zsh 下，只需要输入每个路径的头字母然后 tab 一下： <code>cd /u/p/w/p/s/m/w/s/j&lt;TAB&gt;</code></p>
<h3 id="理由_5：zsh_强大的快速目录切换">理由 5：zsh 强大的快速目录切换</h3>
<p>以前最苦逼的事情莫过于频繁在两个工作目录下切换，总要打一长串 <code>cd</code> 路径。也尝试过 <code>popd</code> 和 <code>pushd</code> 来解决这个问题，但往往是目录已经切换了才想起来没用 <code>pushd</code>。而 zsh 会记住你每一次切换的路径，然后通过 <code>1</code> 来切换到你上一次访问的路径，<code>2</code> 切换到上上次……一直到 <code>9</code>，还可以通过 <code>d</code> 查看目录访问历史。</p>
<p>zsh 还可以配合 autojump 一起使用，autojump 会记录下每一个你访问过的目录，然后通过 <code>j</code> 来快速跳转。</p>
<h3 id="理由_6：zsh_支持全局_alias_和后缀名_alias">理由 6：zsh 支持全局 alias 和后缀名 alias</h3>
<p>bash 的 <code>alias</code> 只能做命令的缩写，而 <code>zsh</code> 更进一步，使 <code>alias</code> 可以缩写命令的一部分，例如参数或环境变量设置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>$ alias <span class="operator">-s</span> log=less
$ ~/package/tomcat/log/catalina.log <span class="comment"># 相当于 less ~/package/tomcat/log/catalina.log</span>
$ alias -g PR=http_proxy=<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8087</span>
$ PR curl https://twitter.com <span class="comment"># 相当于 http_proxy=127.0.0.1:8087 curl https://twitter.com</span>
</pre></td></tr></table></figure>

<h3 id="理由_7：zsh_有着丰富多彩的命令行提示符">理由 7：zsh 有着丰富多彩的命令行提示符</h3>
<p>bash 下通过设置 <code>$PS1</code> 已经可以实现很丰富的提示符了，而 zsh 更进一步，可以实现诸如多行提示符、提示符右对齐等功能。<code>oh-my-zsh</code> 配置文件中提供了非常丰富的提示符 theme 供选择，我使用的是 <code>gentoo</code> 主题，比较简洁，还可以显示当前 git 仓库的状态。</p>
<h3 id="理由_8：zsh_有更多优雅的语法">理由 8：zsh 有更多优雅的语法</h3>
<p>例如修改 <code>PATH</code>，bash 下设置 <code>$PATH</code> 要求所有路径都要写在一行里，目录多了以后看起来就很难看。zsh 支持更加符合程序员审美观的设置方式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>path=(
    ~/bin
    <span class="variable">$path</span>
    ~/package/smartsprites/bin
)
</pre></td></tr></table></figure>

<h2 id="安装_zsh">安装 zsh</h2>
<p>Linux 用户通过各自发行版的包管理器直接安装即可。</p>
<p>Mac 自带一个 4.x.x 版本的 zsh，可以直接使用，也可以通过 homebrew 安装最近刚刚发布的 5.0.0 版本。推荐使用最新的 5.0 版本，对多字节字符提供了完整的支持，这一点对于国内用户来说很重要。<a href="http://zsh.sourceforge.net/releases.html" target="_blank">详细的 release note</a></p>
<h3 id="设置为默认_shell">设置为默认 shell</h3>
<p>通过命令 <code>chsh</code> 修改默认登录 shell，需要注意的是，如果通过 homebrew 安装了最新版本的 zsh，则需要 <code>sudo</code>  编辑 <code>/etc/shells</code> 加入一行 <code>/usr/local/bin/zsh</code>。然后再通过 <code>chsh</code> 来修改默认 shell，否则会提示 <code>/usr/local/bin/zsh</code> 不是合法的 shell。</p>
<h2 id="安装_oh-my-zsh_配置">安装 oh-my-zsh 配置</h2>
<p>对于每一个像我这样的 zsh 初级用户来说，oh-my-zsh 就是救人于水火中的大杀器，强烈建议使用此配置上手 zsh。</p>
<p>作者提供了傻瓜安装命令：</p>
<pre><code>curl -<span class="constant">L</span> <span class="symbol">https:</span>/<span class="regexp">/github.com/robbyrussell</span><span class="regexp">/oh-my-zsh/raw</span><span class="regexp">/master/tools</span><span class="regexp">/install.sh | sh</span>
</code></pre><p>也可以手工安装，<a href="https://github.com/robbyrussell/oh-my-zsh#the-manual-way" target="_blank">具体步骤</a>。</p>
<h2 id="几个必备的插件">几个必备的插件</h2>
<h3 id="autojump">autojump</h3>
<p>帮助快速目录跳转的小工具。首先要安装 autojump，然后在 <code>.zshrc</code> 中开启 autojump 插件。它会记录下来每个你进入过的目录，随后通过 <code>j 目录名称的一部分</code> 就可快速跳转到该目录。 <a href="http://youtu.be/tnNyoMGnbKg" target="_blank">Youtube 视频介绍</a></p>
<h3 id="git">git</h3>
<p>Git 命令补全，除了可以补全 git 的子命令、命令开关等常规补全项以外，还可以补全分支名等内容，用 git 必开的插件。</p>
<h3 id="osx">osx</h3>
<p>提供一些与 Mac OSX 系统交互的命令，比如：</p>
<ul>
<li>man-preview 通过 preview 程序查看一个命令的手册，例如 <code>man-preview git</code></li>
<li>quick-look 快速预览文件</li>
<li>pfd 返回当前 finder 打开的文件夹的路径</li>
<li>cdf 切换到当前 finder 所在的目录</li>
</ul>

        <p>- FIN -</p>
      
    </div>
    
    <footer class="article-footer">
      <a data-url="http://lostjs.com/2012/09/27/zsh/" data-id="j7a26i4yekmrdesr" class="article-share-link">分享</a>
      
      
        <a href="http://lostjs.com/2012/09/27/zsh/#comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zsh/">zsh</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-mustache-precompile-with-hogan" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2012/08/30/mustache-precompile-with-hogan/" class="article-date">
  <time datetime="2012-08-30T08:18:00.000Z" itemprop="datePublished">2012年08月30日</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/08/30/mustache-precompile-with-hogan/">Mustache.js/Hogan.js 模板预编译</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://github.com/janl/mustache.js" target="_blank">mustache.js</a> 是<a href="http://fenbi.com" target="_blank">粉笔网</a>用的一个开源前端模板引擎，无逻辑的设计，简单好用，性能也不错。</p>
<figure class="highlight javascript"><figcaption><span>一个简单的 mustache.js 渲染例子 demo.js</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">var</span> template = <span class="string">"hello {name}}!"</span>; <span class="comment">// 因为代码高亮插件的 bug，这里 name 左边少了一个 {，实际代码中要加上</span>
console.log(Mustache.render(template, {name: <span class="string">"foo"</span>})); <span class="comment">// hello foo!</span>
console.log(Mustache.render(template, {name: <span class="string">"bar"</span>})); <span class="comment">// hello bar!</span>
</pre></td></tr></table></figure>

<p>Mustache 在 render 一个模板时，首先会将这个模板编译成一个模板函数。比如上面例子里的 <code>hello {{name}}</code> 模板，会被编译成一个模板函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">anonymous</span><span class="params">(c, r)</span> {</span>
    <span class="keyword">return</span> <span class="string">""</span> + <span class="string">"hello\u0020"</span> + r._name(<span class="string">"name"</span>, c, <span class="literal">true</span>) + <span class="string">"\u0021"</span>;
}
</pre></td></tr></table></figure>

<p>大规模应用时，模板的编译过程会花掉整个 render 过程中 30% 左右的时间。</p>
<h2 id="使用_Hogan-js_预编译_Mustache_模板">使用 Hogan.js 预编译 Mustache 模板</h2>
<p>Mustache 模板的这个问题已经被不少人遇到，也有很多解决办法。比如 twitter 发布的 <a href="http://twitter.github.com/hogan.js" target="_blank">Hogan.js</a>。Hogan.js 是 Mustache 模板引擎的另一套实现，增加了预编译机制，使得模板字符串可以在打包阶段被预先处理成模板函数，这样浏览器就不必再重复去编译模板。</p>
<p>Hogan.js 同时提供了可以运行与浏览器端和 node.js 环境下的代码，node.js 负责打包时预编译，浏览器端负责用预编译后的代码渲染页面。</p>
<p>首先通过 npm 安装 hogan.js 的 node.js 环境：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>npm install hogan.js
</pre></td></tr></table></figure>

<p>然后对源代码进行一些修改，在模板字符串的旁边加上一些标记，让打包脚本可以找到模板字符串：</p>
<figure class="highlight javascript"><figcaption><span>修改后的例子 demo.js</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="keyword">var</span> Template = {
    _cache: {},

    <span class="comment">// 所有的模板放在这个对象下</span>
    _template: {
        hello: <span class="comment">/*TMPL*/</span><span class="string">"hello {name}}!"</span><span class="comment">/*TMPL*/</span> <span class="comment">// 因为代码高亮插件的 bug，这里 name 左边少了一个 {，实际代码中要加上</span>
    },

    <span class="comment">// 这个适配函数会同时处理字符串模板和模板函数的情况</span>
    render: <span class="function"><span class="keyword">function</span> <span class="params">(name, data)</span> {</span>
        <span class="keyword">if</span> (!<span class="keyword">this</span>._cache[name]) {
            <span class="comment">// 如果代码被预编译过，则不需要 compile</span>
            <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>._template[name] === <span class="string">'function'</span>) {
                <span class="keyword">this</span>._cache[name] = <span class="keyword">new</span> Hogan.Template(<span class="keyword">this</span>._template[name]);
            } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>._template[name] === <span class="string">'string'</span>) {
                <span class="keyword">this</span>._cache[name] = Hogan.compile(<span class="keyword">this</span>._template[name]);
            }
        }

        <span class="keyword">return</span> <span class="keyword">this</span>._cache[name].render(data);
    }
};

console.log(Template.render(<span class="string">'hello'</span>, {name: <span class="string">"foo"</span>})); <span class="comment">// hello foo!</span>
console.log(Template.render(<span class="string">'hello'</span>, {name: <span class="string">"bar"</span>})); <span class="comment">// hello bar!</span>
</pre></td></tr></table></figure>


<figure class="highlight javascript"><figcaption><span>nodejs 环境中的预编译过程</span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">var</span> hogan = <span class="built_in">require</span>(<span class="string">"hogan.js"</span>);
<span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);
<span class="keyword">var</span> fileContent = fs.readFileSync(<span class="string">"demo.js"</span>, <span class="string">"utf-8"</span>);
fileContent.replace(<span class="regexp">/\/\*TMPL\*\/"(.*?)"\/\*TMPL\*\//g</span>, <span class="function"><span class="keyword">function</span> <span class="params">($0, $1)</span> {</span>
    <span class="keyword">return</span> hogan.compile($<span class="number">1</span>, {
        asString: <span class="literal">true</span>
    });
});
fs.writeFileSync(<span class="string">"demo.js"</span>, fileContent, <span class="string">"utf-8"</span>);
</pre></td></tr></table></figure>

<p>源代码编译完之后，模板字符串就变成了模板函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">/* ... */</span>
    hello: <span class="function"><span class="keyword">function</span><span class="params">(c,p,i)</span>{</span><span class="keyword">var</span> _=<span class="keyword">this</span>;_.b(i=i||<span class="string">""</span>);_.b(<span class="string">"hello "</span>);_.b(_.v(_.f(<span class="string">"name"</span>,c,p,<span class="number">0</span>)));_.b(<span class="string">"!"</span>);<span class="keyword">return</span> _.fl();;}
<span class="comment">/* ... */</span>

console.log(Template.render(<span class="string">'hello'</span>, {name: <span class="string">"foo"</span>})); <span class="comment">// hello foo!</span>
console.log(Template.render(<span class="string">'hello'</span>, {name: <span class="string">"bar"</span>})); <span class="comment">// hello bar!</span>
</pre></td></tr></table></figure>

<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="http://www.grobmeier.de/precompiling-hogan-jsmustache-templates-on-a-java-server-with-struts-2-16012012.html#.UD82lmhiivI" target="_blank">Precompiling hogan.js/mustache templates on a Java server with Struts 2</a></li>
</ul>

        <p>- FIN -</p>
      
    </div>
    
    <footer class="article-footer">
      <a data-url="http://lostjs.com/2012/08/30/mustache-precompile-with-hogan/" data-id="a67bou2f420mwsok" class="article-share-link">分享</a>
      
      
        <a href="http://lostjs.com/2012/08/30/mustache-precompile-with-hogan/#comments" class="article-comment-link">评论</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mustache/">mustache</a></li></ul>

    </footer>
  </div>
  
</article>




  
  
    <nav id="page-nav">
      <a class="extend prev" href="/archives/page/3/">&laquo; 上一页</a><a class="page-number" href="/archives/">1</a><a class="page-number" href="/archives/page/2/">2</a><a class="page-number" href="/archives/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/archives/page/5/">5</a><a class="extend next" href="/archives/page/5/">下一页 &raquo;</a>
    </nav>
  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/grunt/">grunt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mustache/">mustache</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/">vim</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zsh/">zsh</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/招聘/">招聘</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04">四月 2014</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02">二月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01">一月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10">十月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07">七月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12">十二月 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09">九月 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/08">八月 2012</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/02">二月 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/12">十二月 2011</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2014/04/24/router-in-express-4/">浅谈 Express 4.0 Router 模块</a>
          </li>
        
          <li>
            <a href="/2014/04/24/upgrade-express-4/">Express 4.0 升级手记</a>
          </li>
        
          <li>
            <a href="/2014/04/23/replace-nginx-by-node/">用 node 代替 nginx 做请求分发</a>
          </li>
        
          <li>
            <a href="/2014/04/22/from-octopress-to-hexo/">把 blog 从 octopress 迁移到 hexo</a>
          </li>
        
          <li>
            <a href="/2014/04/21/a-simple-promise-cache-by-lru-cache/">异步、promise 与缓存</a>
          </li>
        
      </ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2014 张宇辰 (pw)<br>
      Powered by <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
</nav>
    


<script type="text/javascript">
var duoshuoQuery = {
    short_name: "lostjs"
};
(function () {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';
    ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>


<script type="text/javascript" src="/js/script.js"></script>

  </div>
</body>
</html>